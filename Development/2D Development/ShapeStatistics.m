(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: ShapeStatistics *)

(* :Context: ExpTools`ShapeStatistics` *)

(* :Author: Flip Phillips
	Recent modifications $Id: ShapeStatistics.nb 11 2005-05-16 15:39:57Z flip $ *)

(* :Summary: 
	This package provides various statistical shape functions to Mathematica.
*)

(* :Package Version: $Revision: 11 $ *)

(* :Mathematica Version: 5.1 *)

(* :Copyright: Copyright 2005, Flip Phillips, All Rights Reserved.  *)

(* :History: 
*)

(* :Keywords:
	shape, path, procustus
*)

(* :Limitations:  *)

(* :Discussion:  *)


BeginPackage["ExpTools`ShapeStatistics`"];


ShapeStatistics::usage="ShapeStatistics.m is a package for cacluating various shape statistics.";


ShapeCentroid::usage = "ShapeCentroid[boundary] returns the centroid of boundary.";


ShapeRecenter::usage = "ShapeRecenter[boundary] shifts boundary to be centered at its centroid at (0,0).";


ShapeResample::usage = "ShapeResample[boundary,n] resamples boundary to have 'n' points (default- 50.0)";


FrobeniusNorm::usage="FrobeniusNorm[boundary] returns the normalization length of boundary.";


CentroidSize::usage="CentroidSize[boundary] returns an alternate normalization length of boundary.";


ShapeNormalize::usage="ShapeNormalize[boundary] recenters and normalizes the boundary using a given metric. (Right now, defaults to Frobenius norm but I need to add an option.)";


ShapeAlign::usage="ShapeAlign[{a,b}] rotates a to lie on b, minimizing the given difference metric.";


ProcrustesDistance::usage="ProcrustesDistance[{a,b}] computes the Procrustian Distance betweeen the two unaligned shapes";


ProcrustesMean::usage="ProcrustesMean[{a,b,...}] computes the Procrustian Mean Shape betweeen all (potentially unaligned) shapes";


NPoints::usage="Option to ShapeResample. Number of points to resample to.";


DistanceMetric::usage="Option to ShapeNormalize. Metric to use to normalize points.";


Begin["`Private`"];


Unprotect[{ShapeStatistics,ShapeCentroid,ShapeRecenter,ShapeResample,FrobeniusNorm,CentroidSize,ShapeNormalize,ShapeAlign,ProcrustesDistance,NPoints,DistanceMetric}];


ShapeLength::uneqlen="Shape landmark lists are not the same length.";


ShapeCentroid[b_]:=Mean/@Transpose[b]


ShapeRecenter[b_]:=Module[{cg=ShapeCentroid[b]},
(#-cg)&/@b]


Options[ShapeResample]={NPoints->50};


ShapeResample[b_List,opts___?OptionQ]:=Module[
{n,d,t,targets,sd,keys},

n =NPoints/.{opts}/.Options[ShapeResample];

d=ShapeRecenter[b];
t=Apply[ArcTan,d,{1}];
targets=Rest[Range[-\[Pi],\[Pi],2\[Pi]/n]];
sd=(t-#)^2&/@targets;
keys=Flatten[Position[#,Min[#],{0,Infinity},1]&/@sd];
Part[b,keys]
]


FrobeniusNorm[b_]:=Module[{cg},
cg=ShapeCentroid[b];
Sqrt[Plus@@Apply[Plus,(#-cg)^2&/@b,1]]]


CentroidSize[b_]:=Module[{cg},
cg=ShapeCentroid[b];
Plus@@Sqrt/@(Apply[Plus,(#-cg)^2&/@b,1])]


ShapeNormalize[b_]:=Module[{bb=ShapeRecenter[b]},
bb/FrobeniusNorm[bb]]


ShapeAlign[{b1_,b2_}]:=Module[{nb1,nb2,u,v,w,a},

If[Length[b1]!=Length[b2],Message[ShapeLength::uneqlen];Return[{b1,b2}]];

nb1=ShapeNormalize[b1];
nb2=ShapeNormalize[b2];
{u,w,v}=SingularValueDecomposition[N[ConjugateTranspose[b1].b2]];
a=u.ConjugateTranspose[v];
{nb1.a,nb2}]


ShapeAlign[b1_,b2_]:=ShapeAlign[{b1,b2}]


ProcrustesDistance[b1_,b2_]:=ProcrustesDistance[{b1,b2}]


ProcrustesMean[b_List]:=Module[{template,shapes},
template=b[[1]];
shapes=Map[First[ShapeAlign[#,template]]&,b];
Mean/@Transpose[shapes]]


End[];


Protect[{ShapeStatistics,ShapeCentroid,ShapeRecenter,ShapeResample,FrobeniusNorm,\
CentroidSize,ShapeNormalize,ShapeAlign,ProcrustesDistance,NPoints,\
DistanceMetric}];


EndPackage[];


Null
